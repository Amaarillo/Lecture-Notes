# Exam Prep
## Lecture 4
### Specification 1

Summary: 
---

Keywords: 
### Functional Requirement: 
What kinds of functions a software shall have and adhere to, can be specified in a multitude of ways: 
* Context Diagram: Graphical Description of the system and its users and external sources like APIs. Very Useful
* Event and Functions List: List of events and functions, good as checklist for validation
* Feature Requirements: Textual descriptions of features that the system shall have, "The system shall..."
* Prototypes and Screens: Screen pictures with buttons, describes in a graphical way what does what.
* Task Descriptions : Describes the task, with the Frequency, triggers sub tasks and so forth.
* Task and Support: 
* (Vivid) Scenarios: Gives a vivid story to jusify something.
* High Level Tasks: Very high level tasks, like "Stay at a hotel"
* Use cases: User wants to, beacuse
* Data flow Diagram: Bubble diagram showing functins and data travelling in between.
* Standard as. Requirement: Describes standards that shall be adhered to.
* Development Process Requirement: Describes requirements dfor the dev. provcess. The developer shall...

### Data Requirement 
What kind of data will flow in the software, can be specified in multible ways as well.

What are the advantages and disadvantages for the following?:
* E/R - Dragram: Block diagram describing the data inside and outside of the product. Should be precise
* Data Dictionary: Textual Description of the data. Easy to understand. Exhaustive to write and expensive. Consists of descriptions for each of the entities (Classes) 
* Data Expressions: Textual easy way for writing the data.
* Virtual Windows: Graphical representation of the data absent of buttons and menus.

### Functional Details 

* Complex and Simple functions: Describe semi complex functions 
* Tables and decision tables: Tables listing all possibilities, for example for discount.
* Textual Process descriptions: Psuedo code for dunctions
* State Diagram: What states the program can be in and how it transisitons in between.
* State- Transition matrices: States and transitions
* Activity Diagrams: Shows flow ofd xontrol and data, good for synchronization.
* Class Diagrams: Descrives the calsses
* Collaboration Diagrams: Describes hopw objects call one another.
* Sequence Diagrams: How sequences are done, between methods and system.

### Special Interfaces
* Reports: What reports shall be produced.
* Platform Requirements: What platform the system shall run on
* Product intergration: FInd other products that can be used with product.
* Technical interfaces: How the system shall communicate with other systems.

All of these techniques have pros and cons, they each have different abstraction levels and thus are suitable for various things. This can depend on the stakeholders, number of requirements and so forth.

## Abstraction levels
There are different abststraction levels, in classical RE they are 
* Product level - The goals (high level)
* Feature level - The various features that a product shall have on a high level. 
* Function Level - The functions a product shall have 
* Component level - Detailed 

In agile development we have other levels 
* Themes
* Epics
* User Stories
* Tasks
 
*What makes a requirement specification good?* 
They should be correct, Complete, Unabigous, Consistent, Ranked by importance, Modifiable, Verifiable and Tracable. That is; all the requirements shall refelect a need while all the parties agree on meaning, all the nessesary functions shall be present and all these shall be consistent while being prioritized and verifyable. Finally tracing shoulb be able to be done on the REQSPEC.

### Why do we have misunderstandings? 
Gulfs of understanding, lack of expertice, finding common grounds and so forth, a structural way of elicitaion is needed. 

Requiements should be simple, with a clear user and goal, while also being able to be verified. Should however avoid unabigiouty, like OR/AND, split these instead.


